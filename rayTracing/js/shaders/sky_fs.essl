Shader.source[document.currentScript.src.split('js/shaders/')[1]] = `
	precision highp float;
	varying vec2 texCoord;
	varying vec4 worldPos;
	varying vec3 worldNormal;
  varying vec4 rayDir;
	uniform sampler2D probeTexture;
	uniform vec4 lightPos[2]; // xyz is the direction, w is 0
	uniform vec4 mainDir[2];
	uniform vec4 lightPowerDensity[2]; // w ignored
	uniform vec3 cameraPos;
	uniform mat4 quadrics[4];
	uniform vec4 brdfs[2];

	// mat4 A1 = mat4(1, 0, 0, 0,
	// 							0, 1, 0, 0,
	// 							0, 0, 1, 0,
	// 							0, 0, 0, -2);
  //
	// mat4 B1 = mat4(0, 0, 0, 0,
	// 							0, 0, 0, 0,
	// 							0, 0, 1, 0,
	// 							0, 0, 0, -.5);

	float intersectClippedQuadric(mat4 A, mat4 B, vec4 e, vec4 d) {
		float a = dot(d * A, d);
		float b = dot(d * A, e) + dot(e * A, d);
		float c = dot(e * A, e);
		float D = b*b-4.0*a*c;

		float a2 = dot(d * B, d);
		float b2 = dot(d * B, e) + dot(e * B, d);
		float c2 = dot(e * B, e);
		//float D2 = b2*b2-4.0*a2*c2;

		if (D < 0.0) {
			return -1.0;
		} else {
		 float t1 = (-b+sqrt(D))/(2.0*a);
		 float t2 = (-b-sqrt(D))/(2.0*a);
		 float rBr1 = t1*t1*a2 + t1*b2 + c2;
		 float rBr2 = t2*t2*a2 + t2*b2 + c2;

		 if (rBr1 > 0.0) {
		 	t1 = -1.0;
		 }
		 if (rBr2 > 0.0) {
		 	t2 = -1.0;
		 }
		 if (t1 < t2 && t1 > 0.0 || t2 < 0.0) {
			return t1;
		 } else {
		 	return t2;
		 }
		}
	}

	float intersectQuadric(mat4 A, vec4 e, vec4 d) {
		float a = dot(d * A, d);
		float b = dot(d * A, e) + dot(e * A, d);
		float c = dot(e * A, e);
		float D = b*b-4.0*a*c;
		if (D < 0.0) {
			return -1.0;
		} else {
		 float t1 = (-b+sqrt(D))/(2.0*a);
		 float t2 = (-b-sqrt(D))/(2.0*a);
		 if (t1 < t2 && t1 > 0.0 || t2 < 0.0) {
		 	return t1;
		 } else {
		 return t2;
		 }
		}
	}

	bool findBestHit(vec4 e, vec4 d, out float bestT, out vec4 bestBrdf, out mat4 bestA) {
		bestT = -1.0;
		bestBrdf = vec4(0,0,0,0);
		//bestA = quadrics[0];

		for(int i=0;i<2;i++) {
			mat4 A = quadrics[i*2];
			mat4 B = quadrics[i*2+1];
			vec4 curBrdf = brdfs[i];
			float curT = intersectClippedQuadric(A, B, e, d);
			if ((curT < bestT || bestT == -1.0) && curT > 0.0) {
				bestT = curT;
				bestBrdf = curBrdf;
				bestA = A;
			}
		}
		return bestT >= 0.0;
	}

	vec4 shading(vec4 d, vec4 r, vec3 normal, vec4 brdf) {
		vec4 finalColor = vec4(0.0, 0.0, 0.0, 1);
    for (int i=0;i<1;i++) {
			vec3 viewDir = (-1.0) * d.xyz;
			vec3 lightDir = lightPos[i].xyz - lightPos[i].w * r.xyz;
			vec3 halfWayVec = normalize(normalize(viewDir) + normalize(lightDir));

			float deviation = max(dot(halfWayVec, normal), 0.0);
			float cosTheta = max(dot(normalize(lightDir), normal), 0.0);

			vec4 powerDensity;
			if (mainDir[i].w == 1.0) {
				powerDensity = lightPowerDensity[i] * pow(max(dot(normalize(mainDir[i].xyz), normalize((-1.0) * lightDir)), 0.0), 8.0);
			} else {
				powerDensity = lightPowerDensity[i];
			}

			vec4 diffuse = vec4 (powerDensity.xyz/(pow(length(lightDir), 2.0)) *
														brdf.xyz * cosTheta, 1);
			finalColor += diffuse;
			if (brdf.w != 0.0 && brdf.w  < 200.0) {
				vec4 specular = vec4 (powerDensity.xyz/(pow(length(lightDir), 2.0)) *
												brdf.xyz * (pow(deviation, brdf.w)), 1);
				finalColor += specular;
			}
		}
		return finalColor;
	}

	void main(void) {
    vec4 d = vec4(normalize(rayDir.xyz), 0);
		vec4 e = vec4(cameraPos, 1);
		float t; vec4 brdf; mat4 A;

    //vec3 viewDir = normalize(cameraPos - worldPos.xyz);
    // compute ideal reflected direction
    //vec3 reflDir = reflect(-viewDir, worldNormal);

    //find corresponding point in light probe
    vec3 m = (normalize(d.xyz + vec3(0, 0, 1))) / 2.0;

    vec2 probeTex = vec2(m.x + .5, -m.y + .5);  //compute this from reflDir as in prev. slide

		//float t = intersectClippedQuadric(A, B, e, d);

		if (findBestHit(e, d, t, brdf, A)) {
			vec4 r = e + d*t;
			vec3 normal = normalize((A*r + r*A).xyz);
			gl_FragColor = shading(d, r, normal, brdf);
		} else {
			gl_FragColor = texture2D(probeTexture, probeTex);
		}
	}
`;
