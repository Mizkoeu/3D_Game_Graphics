Shader.source[document.currentScript.src.split('js/shaders/')[1]] = `
	precision highp float;
	varying vec2 texCoord;
	varying vec4 worldPos;
	varying vec3 worldNormal;
  varying vec4 rayDir;
	uniform sampler2D probeTexture;
	uniform vec4 lightPos[3]; // xyz is the direction, w is 0
	uniform vec4 mainDir[3];
	uniform vec4 lightPowerDensity[3]; // w ignored
	uniform vec3 cameraPos;
	uniform mat4 quadrics[128];
	uniform vec4 brdfs[64];
	const int numShapes = 57;
	const int numLights = 3;

	float intersectClippedQuadric(mat4 A, mat4 B, vec4 e, vec4 d) {
		float a = dot(d * A, d);
		float b = dot(d * A, e) + dot(e * A, d);
		float c = dot(e * A, e);
		float D = b*b-4.0*a*c;

		float a2 = dot(d * B, d);
		float b2 = dot(d * B, e) + dot(e * B, d);
		float c2 = dot(e * B, e);
		//float D2 = b2*b2-4.0*a2*c2;

		if (D < 0.0) {
			return -1.0;
		} else {
		 float t1 = (-b+sqrt(D))/(2.0*a);
		 float t2 = (-b-sqrt(D))/(2.0*a);
		 float rBr1 = t1*t1*a2 + t1*b2 + c2;
		 float rBr2 = t2*t2*a2 + t2*b2 + c2;

		 if (rBr1 > 0.0) {
		 	t1 = -1.0;
		 }
		 if (rBr2 > 0.0) {
		 	t2 = -1.0;
		 }
		 if (t1 > 0.0 && (t1 < t2 || t2 < 0.0)) {
			return t1;
		 } else {
		 	return t2;
		 }
		}
	}

	float findBetterHit(float t1, float t2) {
		if ((t1 < t2 || t2 == -1.0) && t1 > 0.0) {
			return t1;
		} else {return t2;}
	}

	bool findBestHit(vec4 e, vec4 d, out float bestT, out vec4 bestBrdf, out mat4 bestA) {
		bestT = -1.0;
		bestBrdf = vec4(0,0,0,0);
		for(int i=0;i<numShapes;i++) {
			mat4 A = quadrics[i*2];
			mat4 B = quadrics[i*2+1];
			vec4 curBrdf = brdfs[i];
			float t1 = intersectClippedQuadric(A, B, e, d);
			float t2 = intersectClippedQuadric(B, A, e, d);
			float curT = findBetterHit(findBetterHit(t1, t2), bestT);
			if (curT != bestT) {
				bestBrdf = curBrdf;
				bestT = curT;
				if (curT == t1) {
					bestA = A;
				}
				if (curT == t2) {
					bestA = B;
				}
			}
		}
		return bestT >= 0.0;
	}

	bool getBestHit(vec4 e, vec4 d) {
		float bestT = -1.0;
		for(int i=0;i<numShapes;i++) {
			mat4 A = quadrics[i*2];
			mat4 B = quadrics[i*2+1];
			float curT = intersectClippedQuadric(A, B, e, d);
			if ((curT < bestT || bestT == -1.0) && curT > 0.0) {
				return true;
			}
		}
		return false;
	}

	//NOTE: Multiple LightSource!!!
	vec4 shading(vec4 d, vec4 r, vec3 normal, vec4 brdf) {
		vec4 finalColor = vec4(0, 0, 0, 0);
		float shadowT; vec4 bestBrdf; mat4 A;
    for (int i=0;i<numLights;i++) {

			vec3 viewDir = normalize((-1.0) * d.xyz);
			vec3 lightDir = lightPos[i].xyz - lightPos[i].w * r.xyz;

			// NOTE: For diff shadow based on where the light source is
			// findBestHit(r, vec4(normalize(lightDir), 0.0), shadowT, bestBrdf, A);
			// if (shadowT > 0.0 && shadowT*lightPos[i].w < length(lightDir)) {

			// NOTE: for general directional lighting like the sun.
      if (getBestHit(r+vec4(normal*0.001, 0), vec4(normalize(lightDir), 0.0))) {
			 	finalColor += vec4(0, 0, 0, 1);
			} else {
				vec3 halfWayVec = normalize(viewDir + normalize(lightDir));

				float deviation = max(dot(halfWayVec, normal), 0.0);
				float cosTheta = max(dot(normalize(lightDir), normal), 0.0);

				vec4 powerDensity;
				if (mainDir[i].w == 1.0) {
					powerDensity = lightPowerDensity[i] * pow(max(dot(normalize(mainDir[i].xyz), normalize((-1.0) * lightDir)), 0.0), 16.0);
				} else {
					powerDensity = lightPowerDensity[i];
				}

				vec4 diffuse = vec4 (powerDensity.xyz/(pow(length(lightDir), 2.0)) *
															brdf.xyz * cosTheta, 1);
				finalColor += diffuse;
				if (brdf.w != 0.0 && brdf.w  < 200.0) {
					vec4 specular = vec4 (powerDensity.xyz/(pow(length(lightDir), 2.0)) *
													brdf.xyz * (pow(deviation, brdf.w)), 1);
					finalColor += specular;
				}
			}
		}
		return finalColor;
	}

	vec2 findSkyTexture(vec4 d) {
		//find corresponding point in light probe
    vec3 m = (normalize(d.xyz + vec3(0, 0, 1))) / 2.0;
		//compute this from reflDir as in prev. slide
    vec2 probeTex = vec2(m.x + .5, -m.y + .5);
		return probeTex;
	}

	//NOTE: Multiple LightSouce!!!
	vec4 getBoardTexture(vec4 d, vec4 r, vec3 normal, vec4 brdf) {
		// vec4 finalColor;
		// for (int i=0;i<numLights;i++) {
		// 	vec3 lightDir = lightPos[i].xyz - lightPos[i].w * r.xyz;
		// 	// NOTE: for general directional lighting like the sun.
		// 	if (getBestHit(r+vec4(normal*0.001, 0), vec4(normalize(lightDir), 0.0))) {
		// 		return vec4(0, 0, 0, 1);
		// 	} else {
				float cellWidth = 1.3;
				float row = floor(r.x/cellWidth);
				float col = floor(r.z/cellWidth);
				if (row < 4.0 && row >= -4.0 && col < 4.0 && col >= -4.0){
					if (mod((row-col), 2.0) == 1.0) {
						return shading(d, r, normal, vec4(0, 0, 0, 80));
					} else {
						return shading(d, r, normal, vec4(.8, .8, .8, 80));
					}
				}
				return shading(d, r, normal, vec4(.1, .1, .1, 80));
		// 	}
		// }
	}

	void reflectUpdate(inout vec4 e, inout vec4 d, vec4 r, vec3 normal) {
		e = r + vec4(normal*0.001, 0);
		d = vec4(normalize(reflect(d.xyz, normal)), 0);
	}

	void refractUpdate(inout vec4 e, inout vec4 d, vec4 r, vec3 normal, float refraIndex) {
		float cosAlpha = dot(-d.xyz, normal);
		if (cosAlpha < 0.0) {
			cosAlpha = -cosAlpha; normal = -normal; refraIndex = 1.0/refraIndex;
		}
		e = r - vec4(normal*0.01, 0);
		float sinAlphaSqr = 1.0-(pow(cosAlpha, 2.0));
		float cosBetaSqr = 1.0-(sinAlphaSqr/pow(refraIndex, 2.0));
		float cosBeta;
		if (cosBetaSqr < 0.0) {
			cosBeta = 0.0;
		} else { cosBeta = sqrt(cosBetaSqr);}
		d = vec4(normalize((d.xyz + normal*cosAlpha)/refraIndex - normal*cosBeta), 0);
		//d = vec4(refract(d.xyz, normal, 1.0), 0);
	}

	void main(void) {
    vec4 d = vec4(normalize(rayDir.xyz), 0);
		vec4 e = vec4(cameraPos, 1);
		float t; vec4 brdf; mat4 A;

		//contribution RGB from each level of raytracing
		vec3 contrib = vec3(1, 1, 1);

		for (int i=0;i<10;i++) {
			if (findBestHit(e, d, t, brdf, A)) {
					vec4 r = e + d*t;
					vec3 normal = normalize((A*r + r*A).xyz);
					//Rough materials
					if (brdf.w < 200.0) {
						gl_FragColor += shading(d, r, normal, brdf) * vec4(contrib, 1);
						return;
					} else if (brdf.w == 200.0) {
					//Chessboard
						gl_FragColor += getBoardTexture(d, r, normal, brdf) * vec4(contrib, 1);
						//return;
						reflectUpdate(e, d, r, normal);
						contrib *= brdf.xyz;
					}	else if (brdf.w < 300.0) {
					//Smooth materials
						reflectUpdate(e, d, r, normal);
						contrib *= brdf.xyz;
					} else {
					//Dielectric: Refrections...
						//float refraIndex = brdf.w - 300.0;
						refractUpdate(e, d, r, normal, 1.33);
						contrib *= brdf.xyz;
					}
			} else {
					gl_FragColor += texture2D(probeTexture, findSkyTexture(d)) * vec4(contrib, 1);
					return;
			}
		}
		return;
	}
`;
